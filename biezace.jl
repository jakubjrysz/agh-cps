using LinearAlgebra
using CairoMakie

function rozwiazanie(;
    fp::Float64 = 371.56,
    t1::Float64 = 3.58,
    N::Int = 374,
)
    function g(t)
        ifelse(mod(t,1) < 0.5, 1, -1)
    end
    t = range(start = t1, step = 1/fp, length = N)
    y = 3.6 .* g.(1.1 .*t .- 3.5)
    return sum(y)/length(y)
end

function rozwiazanie2(;
    b::Vector{Float64} = [0.002779176257811051, -0.006095411177011039, 0.005823228367814995, 1.5427527354567045e-18, -0.005823228367814995, 0.006095411177011036, -0.0027791762578110502],
    a::Vector{Float64} = [1.0, -3.31224085035553, 6.463943944423244, -7.548662737956758, 6.057000694290197, -2.908174535992974, 0.8227410523946155],
    x::Vector{Float64} = [-0.81, -0.3, 0.11, 0.4, 0.42, 0.7, -0.96, -0.47, -0.45, 0.26, -1.0, 0.7, 0.3, -0.99, 0.66, 0.86, 0.48, 0.66, 0.4, -0.41, -0.32, 0.36, -0.08, 0.13, -0.92],
    L::Int = 54,
)
    N = length(x)
    M = length(b)
    K = length(a)
    y = zeros(N)
    for n in 1:N
        for m in 1:M
            if(n - m + 1 > 0)
                y[n] += b[m]*x[n- m + 1]
            end
        end
        for k in 2:K
            if(n - k + 1 > 0)
                y[n] -= a[k]*y[n - k + 1]
            end
        end
    end
    return sum(y)/length(y)
end

function rozwiazanie3(;
    b::Vector{Float64} = [0.20589786767603166, -1.0861272640549327, 3.6226396155444696, -8.22906790017682, 14.482720679302624, -19.905487411076226, 22.227044074733804, -19.905487411076216, 14.482720679302618, -8.229067900176823, 3.622639615544471, -1.0861272640549329, 0.20589786767603174],
    a::Vector{Float64} = [1.0, -4.1018701585332575, 10.455001599833523, -18.605035749010852, 26.070359755268754, -29.249185399188946, 27.385569042192053, -21.411122854097236, 14.268286978394032, -7.919156210490829, 3.6616776168783667, -1.264252062931731, 0.2863185566670542],
    F::Vector{Float64} = [0.07, 0.09, 0.15, 0.2, 0.32],
)
    a_len = length(a)
    b_len = length(b)
    f_len = length(F)

    liczniki = zeros(ComplexF64, f_len)
    mianowniki = zeros(ComplexF64, f_len)

    for i in eachindex(F)
        z = exp(im * 2 * π * F[i])
        for k in 1:b_len
            liczniki[i] += b[k] * z^(- k + 1) 
        end
        for k in 1:a_len
            mianowniki[i] += a[k] * z^(- k + 1)
        end
    end
    gains = abs.([liczniki[i]/mianowniki[i] for i in eachindex(liczniki)])
    avg_gains = sum(gains)/length(gains)
    return avg_gains

end

function rozwiazanie4(;
    fp::Int=1620, #fn = 810
    x::Vector{ComplexF64}=ComplexF64[0.36-0.96im, -0.12-0.24im, -0.71-0.15im, -0.41+0.04im, 0.41-0.01im, -0.42+0.46im, -1.07+0.16im, -0.2-0.5im, 0.91+1.18im, -0.04-0.11im, -0.95-0.29im, 0.06-0.89im, -0.56+0.46im, 0.68+0.04im, -0.67-1.77im, 0.33-0.24im, 1.08+0.44im, -1.14+0.16im, 0.17-0.18im, -0.15-0.3im, 0.85+0.3im, 1.04+1.48im, -0.37-0.03im, 0.3-0.79im, 0.21-0.37im, -0.29-1.15im, -0.44-0.6im, 0.67+0.53im, 1.17+0.93im, -0.09+0.82im, -0.7+0.27im, -1.03+0.99im, 1.1+0.58im, -0.36-0.49im, -1.18+0.14im, -0.03-0.33im, 1.1-0.51im, -0.23+0.36im, -0.49+0.01im, 0.32+0.77im, 0.22+0.58im, 0.25-0.72im, -0.3+0.04im, 0.85+1.03im, 0.43+0.92im],
    f::Vector{Int}=[-36, 252, 360, 396],
)
    N = length(x)
    delta_f = fp / N # równa sie 36
    X = 1/N .* [sum(x[n] * exp(-im * 2 * π * (k - 1) * (n - 1) / N) for n in 1:N) for k in 1:N]        #pierwsza próbka odpowiada f = 0, później 36, 42 itp aż do 420, później -420 aż do -22
    suma_amp = abs(X[8]) + abs(X[11]) + abs(X[12]) + abs(X[45])
    return suma_amp
end
#8 = 252, 11 = 360, 12 = 396 , 23 = 792, 24 = -792, 45 = -36
#działa!!! trzeba normalizowac


function rozwiazanie5(;
    order::Int = 44,
    fp::Float64 = 190.0,
    f0::Float64 = 17.1,
    z::Vector{Int} = [20, 12, 6],
)
    kronecker(n) = ifelse(n == 0, 1, 0)
    fn = f0/fp
    M = div(order,2)
    h = [2*fn*sinc(2*fn*n) for n in -M:M]
    w = [0.54 + 0.46*cos(2*pi*n / (2*M + 1)) for n in -M:M]
    hw = h .* w
    suma = sum(hw[i] for i in z)
    return suma
end
# działa


function rozwiazanie6(;
    b::Vector{Float64} = [0.5714654181096676, -3.6548462159113435, 12.184770642960807, -26.492571511694212, 41.23527906042584, -47.585143698196894, 41.23527906042584, -26.49257151169421, 12.184770642960808, -3.6548462159113444, 0.5714654181096677],
    a::Vector{Float64} = [1.0, -5.734799907386861, 17.084159616729256, -33.13781114381352, 45.88765427844421, -46.9223637139893, 35.80658729852799, -20.07466514801493, 7.947460511819786, -2.010339240203334, 0.25716853747132096],
    x::Vector{Float64} = [-0.91, 0.43, 0.35, 0.3, -0.09, 0.12, -0.25, 0.79, -0.95, 0.29, 0.74, -0.54, 0.27, -0.94, -0.46, 0.81, 0.53, -0.24, -0.19, 0.04, 0.25, 0.13, -0.58, -0.15, -0.32, -0.27],
    L::Int = 54,
)
    b_len = length(b)
    a_len = length(a)
    N = length(x)
    x_padded = vcat(x, zeros(Float64, L - N))
    y = zeros(L)
    for n in 1:L
        for m in 0:b_len - 1
            if n - m > 0
                y[n] += b[m + 1] * x_padded[n - m]
            end
        end
        for k in 1:a_len - 1
            if n - k > 0
                y[n] -= a[k + 1] * y[n - k]
            end
        end
    end
    return sum(y.^2)/L
end
# działa

function rozwiazanie7(;
    z::Vector{ComplexF64} = ComplexF64[1.0 + 0.0im, 1.0 + 0.0im, 1.0 + 0.0im],
    p::Vector{ComplexF64} = ComplexF64[1.6631456433997187 - 3.637849167961824im, 0.2512987283895615 + 0.5496733696232977im, 0.1907602022185668 - 0.0im],
    k::Float64 = 0.27802603319090385,
)
    mian = abs.(p)

    if all(mian .< 1)
        wynik = 1.0
    else
        wynik = -1.0
    end

    return wynik
end
# działa

function rozwiazanie8(;
    fp::Float64 = 408.76,
    t1::Float64 = 8.33,
    N::Int = 317,
)
    g(t) = 2 * ((t + 0.5) % 1) - 1
    t = range(start = 0, step = 1/fp, length = N)
    scatter(t, g.(t))
    y = 2.5 .* g.(3.2 .* t .- 1.9)
    return sum(y)/length(y)
end
# nie działa

function rozwiazanie9(;
    a::Float64 = -1.2,
    b::Float64 = 5.1,
    x::Vector{Float64} = [2.0, 2.40379, 2.80757, 3.21136, 3.61514, 4.01893, 4.42271, 4.8265, -1.16972, -0.76593, -0.36215, 0.04164, 0.44543, 0.84921, 1.253, 1.65678, 2.06057, 2.46435, 2.86814, 3.27192, 3.67571, 4.0795, 4.48328, 4.88707, -1.10915, -0.70536, -0.30158, 0.10221, 0.50599, 0.90978, 1.31356, 1.71735, 2.12114, 2.52492, 2.92871, 3.33249, 3.73628, 4.14006, 4.54385, 4.94763, -1.04858, -0.64479, -0.24101, 0.16278, 0.56656, 0.97035, 1.37413, 1.77792, 2.1817, 2.58549, 2.98927, 3.39306, 3.79685, 4.20063, 4.60442, 5.0082, -0.98801, -0.58423, -0.18044, 0.22334, 0.62713, 1.03091, 1.4347, 1.83849, 2.24227, 2.64606, 3.04984, 3.45363, 3.85741, 4.2612, 4.66498, 5.06877, -0.92744, -0.52366, -0.11987, 0.28391, 0.6877, 1.09148, 1.49527, 1.89905, 2.30284, 2.70662, 3.11041, 3.5142, 3.91798, 4.32177, 4.72555],
)
    N = 9
    L = range(start = a, stop = b, length = 2^N)
    
    function quantize(x,L)
        y = L[argmin(abs.(x .- L))]
        return y
    end
    
    x_q = [quantize(xi,L) for xi in x]
    error = x .- x_q
    energy = sum(error.^2)
    power = energy/length(error)
    rms = sqrt(power)
    return rms
end
# działa

function rozwiazanie10(;
    m::Vector{Float64} = [-2.4, -2.3979, -2.3958, -2.3937, -2.3916, -2.3895, -2.3874, -2.3853, -2.3832, -2.3811, -2.379, -2.3769, -2.3748, -2.3727, -2.3706, -2.3685, -2.3664, -2.3643, -2.3622, -2.3601, -2.358, -2.3559, -2.3538, -2.3517, -2.3496, -2.3475, -2.3454, -2.3433, -2.3412, -2.3391, -2.337, -2.3349, -2.3328, -2.3307, -2.3286, -2.3265, -2.3244, -2.3223, -2.3202, -2.3181, -2.316, -2.3139, -2.3118, -2.3097, -2.3076, -2.3055, -2.3034, -2.3013, -2.2992, -2.2971, -2.295, -2.2929, -2.2908, -2.2887, -2.2866, -2.2845, -2.2824, -2.2803, -2.2782, -2.2761, -2.274, -2.2719, -2.2698, -2.2677, -2.2656, -2.2635, -2.2614, -2.2593, -2.2572, -2.2551, -2.253, -2.2509],
    s::Vector{Float64} = [0.7452, 0.7087, 0.0138, 0.8951, 0.4073, 0.4276, 0.0448, 0.5468, 0.3452, 0.1164, 0.3736, 0.2974, 0.2617, 0.4393, 0.4261, 0.5137, 0.9904, 0.1674, 0.1667, 0.4039, 0.8123, 0.0702, 0.1954, 0.9833, 0.158, 0.7952, 0.8701, 0.3193, 0.7808, 0.689, 0.2071, 0.2962, 0.7494, 0.63, 0.8938, 0.8828, 0.393, 0.4709, 0.606, 0.5863, 0.5103, 0.7919, 0.2988, 0.4287, 0.386, 0.0663, 0.1574, 0.8301, 0.311, 0.6848, 0.1811, 0.5569, 0.281, 0.9884, 0.8383, 0.1676, 0.6669, 0.6685, 0.6016, 0.7637, 0.6428, 0.5916, 0.1587, 0.8124, 0.1038, 0.7768, 0.432, 0.5818, 0.8524, 0.3411, 0.9134, 0.9618],
    t::Vector{Float64} = [-2.31558, -2.38068, -2.34225, -2.27631, -2.2551, -2.39433, -2.32818, -2.37291, -2.27442, -2.27883],
)
    delta_t = m[2] - m[1]
    x = [sum(s[k] * sinc((ti - m[k])/delta_t) for k in eachindex(m)) for ti in t]
    return sum(x)
end
# działa

function rozwiazanie11(;
    x::Vector{Float64} = [2.89, -2.01, 1.42, 3.24, 3.05, -2.63, 2.88, 0.35, 0.99, -0.87, -0.83, 4.14, -3.45, -1.57, -3.58, -2.37, -2.19, -4.31, -4.64, 4.88, 0.12, -1.53, -2.76, 2.91, 0.57, 1.38, -0.85, -4.75, 1.01, -1.97, 4.85, -1.33, 0.32, 3.04, -4.91, -2.57, -3.8, 2.79, -2.76, 4.35, 0.11, 3.7, -4.47, -4.17, -2.34, -2.89, -2.3, 1.14, 4.63, -2.67, 3.24, 2.48, -0.36, 2.75, 1.1, -1.86, -0.02, -4.55, 4.84, 3.46, 2.96, 3.02],
    h::Vector{Float64} = [-3.22, 2.85, 4.8, -1.03, -3.56, 1.72, 0.52, -1.6, 1.97, 3.73, -1.43, 2.86, 0.51, -2.56, -1.39],
)
    n = length(x)
    m = length(h)
    y = zeros(n + m - 1)

    for i in 1:n
        for j in 1:m
            y[i + j - 1] += x[i] * h[j] 
        end
    end
    en = sum(y.^2)
    return en
end
# działa

function rozwiazanie12(;
    z::Vector{ComplexF64} = ComplexF64[1.0 + 0.0im, 1.0 + 0.0im, 1.0 + 0.0im, 1.0 + 0.0im, 1.0 + 0.0im],
    p::Vector{ComplexF64} = ComplexF64[0.415879470880599 - 0.8235448265333332im, 0.415879470880599 + 0.8235448265333332im, 0.049248857019034135 - 0.686870715924473im, 0.049248857019034135 + 0.686870715924473im, -0.35831713448925134 + 0.0im],
    k::Float64 = 0.0846119006068186,
)
    p_abs = abs.(p)
    s = 0.0
    if all(p_abs .< 1)
        return 1.0
    else
        return -1.0
    end
end
#działa

function rozwiazanie13(;
    b::Vector{Float64} = [0.0042036847822194195, 0.0210184239110971, 0.0420368478221942, 0.0420368478221942, 0.0210184239110971, 0.0042036847822194195],
    a::Vector{Float64} = [1.0, -2.706368477287315, 3.842079062472673, -3.203777928793533, 1.5618466716574666, -0.35926141501827],
    F::Vector{Float64} = [0.09, 0.19, 0.41, 0.44, 0.49],
)
    b_len = length(b)
    a_len = length(a)
    f_len = length(F)
    liczniki = zeros(ComplexF64, f_len)
    mianowniki = zeros(ComplexF64, f_len)
    y = zeros(ComplexF64, f_len)

    for i in 1:f_len
        z = exp(- im * 2 * π * F[i])
        for j in 1:b_len
            liczniki[i] += b[j] * z^(j - 1)
        end
        for j in 1:a_len
            mianowniki[i] += a[j] * z^(j - 1)
        end
    y[i] = liczniki[i]/mianowniki[i]
    end
    return (sum(angle.(y)))/f_len
end
#działa

function rozwiazanie14(;
    a::Float64 = 0.0056,
    b::Float64 = 1.0,
    x::Vector{Float64} = [0.56847, 0.74211, 0.37596, 0.9346, 0.08945, 0.00563, 0.57125, 0.75471, 0.16204, 0.38112, 0.95479, 0.6514, 0.55112, 0.35259, 0.69607, 0.16842, 0.96484, 0.28371, 0.67609, 0.06089, 0.15291, 0.47616, 0.88706, 0.02472, 0.71574, 0.99689, 0.13549, 0.45939, 0.72669, 0.12584, 0.68082, 0.49304, 0.39996, 0.70337, 0.54443, 0.80433, 0.69674, 0.86164, 0.72668, 0.80791, 0.12616, 0.75179, 0.57159, 0.11995, 0.71875, 0.27166, 0.04843, 0.46238, 0.68282, 0.3623, 0.66588, 0.80024, 0.97114, 0.9802, 0.77712, 0.82037, 0.50873, 0.96565, 0.96343, 0.95378, 0.4523, 0.81601, 0.53997, 0.07107, 0.15579, 0.96985, 0.98929, 0.21106, 0.0927, 0.89756, 0.77855, 0.91343, 0.30874, 0.52587, 0.08481, 0.11552, 0.7191],
)
    N = 6
    L = range(start = a, stop = b, length = 2^N)
    xq = zeros(length(x))
    function quantize(x, L)
        return L[argmin(abs.(L .- x))]
    end

    for i in eachindex(xq)
        xq[i] = quantize(x[i], L)
    end
    err = abs.(xq .- x)
    return sum(err.^2)
end
#działa

function rozwiazanie15(;
    order::Int = 90,
    fp::Float64 = 192.0,
    f0::Float64 = 53.76,
    z::Vector{Int} = [44, 16, 2, 61],
)
    fn = f0/fp
    kronecker(n) = ifelse(n == 0, 1, 0)
    M = div(order,2)
    h = [kronecker(n) - 2*fn*sinc(2*n*fn) for n in -M:M]
    w = [1 - abs(n)/(M + 1) for n in -M:M]
    hw = h.*w
    out = [hw[i] for i in z]
    return sum(out)
end
#działa

function rozwiazanie16(;
    fp::Int = 940,
    x::Vector{ComplexF64} = ComplexF64[-0.65 - 0.67im, -0.29 - 1.34im, -1.28 + 0.2im, -0.44 + 0.15im, 1.0 + 0.05im, -0.66 - 0.1im, 0.08 + 0.24im, -1.17 + 0.43im, 0.05 + 0.85im, -0.5 - 0.46im, -0.24 + 0.16im, 0.76 - 0.29im, 0.35 + 0.09im, -1.85 + 1.1im, -0.51 - 0.12im, -0.29 + 1.02im, -0.31 + 1.76im, -0.55 - 0.15im, 0.1 - 0.7im, -0.0 + 0.52im, 1.2 - 1.01im, 0.45 + 0.71im, 1.73 + 0.9im, -0.54 + 1.56im, -0.22 + 0.4im, -0.16 - 0.44im, -0.78 + 0.24im, 0.52 + 1.06im, -0.8 - 0.85im, -0.2 - 1.5im, 0.81 - 0.95im, 0.91 + 0.35im, -0.18 - 0.57im, -0.66 + 0.81im, 1.14 + 0.02im, -0.65 + 1.58im, 0.06 - 0.47im, -0.46 + 0.35im, -0.48 - 0.18im, 0.5 - 0.68im, 0.02 - 1.54im, -1.47 - 1.26im, -0.37 - 1.14im, 0.08 - 0.32im, -1.19 - 1.9im, -0.04 - 0.37im, -1.39 - 1.23im],
    f::Vector{Int} = [-380, -360, -260, -60, -20, 180, 360],
)
    #w jądrze k/N = fn
    f_len = length(f)
    N = length(x)
    fn = [f[i]/fp for i in 1:f_len]

    X_f = 1/N .* [sum(x[n + 1] * exp(-im * 2 * pi * n * fi) for n in 0:N-1) for fi in fn]

    return sum(abs.(X_f))
end

function rozwiazanie17(;
    x::Vector{Float64} = [3.95, -3.92, 0.72, 2.89, -4.49, 4.25, -2.76, 2.85, 2.62, 1.96, -1.96, -2.94, 4.22, 3.53, 1.58, 4.46, -2.89, 3.41, 2.82, 0.46, -3.47, 4.93, 3.99, 3.49, -2.89, 2.29, 4.35, 4.84, -3.91, -4.37, -1.2, -1.27, 2.38, 3.48, 2.72, 2.37, 2.19, -3.66, -4.74, -3.1, -2.14, -4.18, 1.63, -4.46, -1.81, -2.09, 3.93, -3.82, 4.81, -3.06, 3.29, -1.63, 3.77, -4.55, -4.16, -0.5, 3.91, -2.53, 2.03, -2.88, 3.77, -3.25],
    h::Vector{Float64} = [1.46, -4.11, 0.82, -2.47, 0.76, 0.86, 2.3, 3.16, -0.75, -2.04],
)
    x_len = length(x)
    h_len = length(h)
    y_len = x_len + h_len - 1
    y = zeros(y_len)

    for i in 1:x_len
        for j in 1:h_len
            y[i + j - 1] += x[i] * h[j]
        end
    end
    power = sum(y.^2)/y_len
    return power
end
#działa

function rozwiazanie18(;
    zz::Vector{ComplexF64} = ComplexF64[1.0 + 0.0im, 1.0 + 0.0im, 1.0 + 0.0im, 1.0 + 0.0im, 1.0 + 0.0im, 1.0 + 0.0im, -1.0 + 0.0im, -1.0 + 0.0im, -1.0 + 0.0im, -1.0 + 0.0im, -1.0 + 0.0im, -1.0 + 0.0im],
    pp::Vector{ComplexF64} = ComplexF64[0.543701277994591 - 0.8319925555042785im, 0.29457887606763117 + 0.9483370303390719im, 0.543701277994591 + 0.8319925555042785im, 0.29457887606763117 - 0.9483370303390719im, 0.508848478970115 - 0.8409843938995955im, 0.3274254690915373 + 0.9249844307416222im, 0.508848478970115 + 0.8409843938995955im, 0.3274254690915373 - 0.9249844307416222im, 0.45219457592657175 - 0.864724019694428im, 0.3858890222126597 + 0.8953357230268396im, 0.45219457592657175 + 0.864724019694428im, 0.3858890222126597 - 0.8953357230268396im],
    k::Float64 = 2.9839279959995376e-7,
    F::Vector{Float64} = [0.13, 0.22, 0.43, 0.48],
)
    z_len = length(zz)
    p_len = length(pp)
    f_len = length(F)

    liczniki = ones(ComplexF64, f_len)
    mianowniki = ones(ComplexF64, f_len)
    y = zeros(ComplexF64, f_len)

    for i in 1:f_len
        z = exp(im * 2 * π * F[i])
        for j in 1:z_len
            liczniki[i] *= (1 - zz[j] * z^(-1))
        end
        for j in 1:p_len
            mianowniki[i] *= (1 - pp[j] * z^(-1))
        end
        y[i] = liczniki[i]/mianowniki[i]
    end
    return sum(angle.(y))/f_len
end
#działa
rozwiazanie18()