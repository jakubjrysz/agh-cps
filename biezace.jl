using LinearAlgebra
using CairoMakie

function rozwiazanie(;
    fp::Float64 = 371.56,
    t1::Float64 = 3.58,
    N::Int = 374,
)
    function g(t)
        ifelse(mod(t,1) < 0.5, 1, -1)
    end
    t = range(start = t1, step = 1/fp, length = N)
    y = 3.6 .* g.(1.1 .*t .- 3.5)
    return sum(y)/length(y)
end

function rozwiazanie2(;
    b::Vector{Float64} = [0.002779176257811051, -0.006095411177011039, 0.005823228367814995, 1.5427527354567045e-18, -0.005823228367814995, 0.006095411177011036, -0.0027791762578110502],
    a::Vector{Float64} = [1.0, -3.31224085035553, 6.463943944423244, -7.548662737956758, 6.057000694290197, -2.908174535992974, 0.8227410523946155],
    x::Vector{Float64} = [-0.81, -0.3, 0.11, 0.4, 0.42, 0.7, -0.96, -0.47, -0.45, 0.26, -1.0, 0.7, 0.3, -0.99, 0.66, 0.86, 0.48, 0.66, 0.4, -0.41, -0.32, 0.36, -0.08, 0.13, -0.92],
    L::Int = 54,
)
    N = length(x)
    M = length(b)
    K = length(a)
    y = zeros(N)
    for n in 1:N
        for m in 1:M
            if(n - m + 1 > 0)
                y[n] += b[m]*x[n- m + 1]
            end
        end
        for k in 2:K
            if(n - k + 1 > 0)
                y[n] -= a[k]*y[n - k + 1]
            end
        end
    end
    return sum(y)/length(y)
end

function rozwiazanie3(;
    b::Vector{Float64} = [0.20589786767603166, -1.0861272640549327, 3.6226396155444696, -8.22906790017682, 14.482720679302624, -19.905487411076226, 22.227044074733804, -19.905487411076216, 14.482720679302618, -8.229067900176823, 3.622639615544471, -1.0861272640549329, 0.20589786767603174],
    a::Vector{Float64} = [1.0, -4.1018701585332575, 10.455001599833523, -18.605035749010852, 26.070359755268754, -29.249185399188946, 27.385569042192053, -21.411122854097236, 14.268286978394032, -7.919156210490829, 3.6616776168783667, -1.264252062931731, 0.2863185566670542],
    F::Vector{Float64} = [0.07, 0.09, 0.15, 0.2, 0.32],
)
    a_len = length(a)
    b_len = length(b)
    f_len = length(F)

    liczniki = zeros(ComplexF64, f_len)
    mianowniki = zeros(ComplexF64, f_len)

    for i in eachindex(F)
        z = exp(im * 2 * π * F[i])
        for k in 1:b_len
            liczniki[i] += b[k] * z^(- k + 1) 
        end
        for k in 1:a_len
            mianowniki[i] += a[k] * z^(- k + 1)
        end
    end
    gains = abs.([liczniki[i]/mianowniki[i] for i in eachindex(liczniki)])
    avg_gains = sum(gains)/length(gains)
    return avg_gains

end

function rozwiazanie4(;
    fp::Int=1620, #fn = 810
    x::Vector{ComplexF64}=ComplexF64[0.36-0.96im, -0.12-0.24im, -0.71-0.15im, -0.41+0.04im, 0.41-0.01im, -0.42+0.46im, -1.07+0.16im, -0.2-0.5im, 0.91+1.18im, -0.04-0.11im, -0.95-0.29im, 0.06-0.89im, -0.56+0.46im, 0.68+0.04im, -0.67-1.77im, 0.33-0.24im, 1.08+0.44im, -1.14+0.16im, 0.17-0.18im, -0.15-0.3im, 0.85+0.3im, 1.04+1.48im, -0.37-0.03im, 0.3-0.79im, 0.21-0.37im, -0.29-1.15im, -0.44-0.6im, 0.67+0.53im, 1.17+0.93im, -0.09+0.82im, -0.7+0.27im, -1.03+0.99im, 1.1+0.58im, -0.36-0.49im, -1.18+0.14im, -0.03-0.33im, 1.1-0.51im, -0.23+0.36im, -0.49+0.01im, 0.32+0.77im, 0.22+0.58im, 0.25-0.72im, -0.3+0.04im, 0.85+1.03im, 0.43+0.92im],
    f::Vector{Int}=[-36, 252, 360, 396],
)
    N = length(x)
    delta_f = fp / N # równa sie 36
    X = 1/N .* [sum(x[n] * exp(-im * 2 * π * (k - 1) * (n - 1) / N) for n in 1:N) for k in 1:N]        #pierwsza próbka odpowiada f = 0, później 36, 42 itp aż do 420, później -420 aż do -22
    suma_amp = abs(X[8]) + abs(X[11]) + abs(X[12]) + abs(X[45])
    return suma_amp
end
#8 = 252, 11 = 360, 12 = 396 , 23 = 792, 24 = -792, 45 = -36
#działa!!! trzeba normalizowac


function rozwiazanie5(;
    order::Int = 44,
    fp::Float64 = 190.0,
    f0::Float64 = 17.1,
    z::Vector{Int} = [20, 12, 6],
)
    kronecker(n) = ifelse(n == 0, 1, 0)
    fn = f0/fp
    M = div(order,2)
    h = [2*fn*sinc(2*fn*n) for n in -M:M]
    w = [0.54 + 0.46*cos(2*pi*n / (2*M + 1)) for n in -M:M]
    hw = h .* w
    suma = sum(hw[i] for i in z)
    return suma
end
# działa


function rozwiazanie6(;
    b::Vector{Float64} = [0.5453003465683296, -4.171050270250664, 16.517610324743334, -43.20708966181583, 82.29982131382502, -119.38603628856912, 134.86976621403613, -119.38603628856913, 82.29982131382505, -43.20708966181584, 16.51761032474334, -4.1710502702506655, 0.5453003465683298],
    a::Vector{Float64} = [1.0, -6.883987105918894, 24.50010613201326, -57.64873159669968, 98.89280243058036, -129.382724937445, 132.0126021182598, -105.69465247036214, 65.98935283538998, -31.41627657502734, 10.903014199427172, -2.501979755818367, 0.2973524686391209],
    x::Vector{Float64} = [0.17, 0.28, -0.39, 0.77, -0.65, 0.08, 0.87, -0.54, -0.82, 0.52, -0.37, 0.1, 0.23, -0.65, -0.83, -0.75, 0.0, -0.12, -0.02, -0.2],
    L::Int = 51,
)
    b_len = length(b)
    a_len = length(a)
    N = length(x)
    x_padded = vcat(x, zeros(Float64, L - N))
    y = zeros(L)
    for n in 1:L
        for m in 0:b_len - 1
            if n - m > 0
                y[n] += b[m + 1] * x_padded[n - m]
            end
        end
        for k in 1:a_len - 1
            if n - k > 0
                y[n] -= a[k + 1] * y[n - k]
            end
        end
    end
    return sum(y.^2)/L
end
# działa

function rozwiazanie7(;
    z::Vector{ComplexF64} = ComplexF64[1.0 + 0.0im, 1.0 + 0.0im, 1.0 + 0.0im],
    p::Vector{ComplexF64} = ComplexF64[1.6631456433997187 - 3.637849167961824im, 0.2512987283895615 + 0.5496733696232977im, 0.1907602022185668 - 0.0im],
    k::Float64 = 0.27802603319090385,
)
    mian = abs.(p)

    if all(mian .< 1)
        wynik = 1.0
    else
        wynik = -1.0
    end

    return wynik
end
# działa

function rozwiazanie8(;
    fp::Float64 = 408.76,
    t1::Float64 = 8.33,
    N::Int = 317,
)
    g(t) = 2 * ((t + 0.5) % 1) - 1
    t = range(start = 0, step = 1/fp, length = N)
    scatter(t, g.(t))
    y = 2.5 .* g.(3.2 .* t .- 1.9)
    return sum(y)/length(y)
end
# nie działa

function rozwiazanie9(;
    a::Float64 = -1.2,
    b::Float64 = 5.1,
    x::Vector{Float64} = [2.0, 2.40379, 2.80757, 3.21136, 3.61514, 4.01893, 4.42271, 4.8265, -1.16972, -0.76593, -0.36215, 0.04164, 0.44543, 0.84921, 1.253, 1.65678, 2.06057, 2.46435, 2.86814, 3.27192, 3.67571, 4.0795, 4.48328, 4.88707, -1.10915, -0.70536, -0.30158, 0.10221, 0.50599, 0.90978, 1.31356, 1.71735, 2.12114, 2.52492, 2.92871, 3.33249, 3.73628, 4.14006, 4.54385, 4.94763, -1.04858, -0.64479, -0.24101, 0.16278, 0.56656, 0.97035, 1.37413, 1.77792, 2.1817, 2.58549, 2.98927, 3.39306, 3.79685, 4.20063, 4.60442, 5.0082, -0.98801, -0.58423, -0.18044, 0.22334, 0.62713, 1.03091, 1.4347, 1.83849, 2.24227, 2.64606, 3.04984, 3.45363, 3.85741, 4.2612, 4.66498, 5.06877, -0.92744, -0.52366, -0.11987, 0.28391, 0.6877, 1.09148, 1.49527, 1.89905, 2.30284, 2.70662, 3.11041, 3.5142, 3.91798, 4.32177, 4.72555],
)
    N = 9
    L = range(start = a, stop = b, length = 2^N)
    
    function quantize(x,L)
        y = L[argmin(abs.(x .- L))]
        return y
    end
    
    x_q = [quantize(xi,L) for xi in x]
    error = x .- x_q
    energy = sum(error.^2)
    power = energy/length(error)
    rms = sqrt(power)
    return rms
end
# działa

function rozwiazanie10(;
    m::Vector{Float64} = [-2.6, -2.5979, -2.5958, -2.5937, -2.5916, -2.5895, -2.5874, -2.5853, -2.5832, -2.5811, -2.579, -2.5769, -2.5748, -2.5727, -2.5706, -2.5685, -2.5664, -2.5643, -2.5622, -2.5601, -2.558, -2.5559, -2.5538, -2.5517, -2.5496, -2.5475, -2.5454, -2.5433, -2.5412, -2.5391, -2.537, -2.5349, -2.5328, -2.5307, -2.5286, -2.5265, -2.5244, -2.5223, -2.5202, -2.5181, -2.516, -2.5139, -2.5118, -2.5097, -2.5076, -2.5055, -2.5034, -2.5013, -2.4992, -2.4971, -2.495, -2.4929],
    s::Vector{Float64} = [0.0342, 0.7635, 0.9769, 0.9945, 0.0031, 0.6869, 0.9992, 0.2636, 0.2944, 0.0338, 0.7125, 0.0051, 0.532, 0.9294, 0.9607, 0.9488, 0.033, 0.9231, 0.2509, 0.8621, 0.1574, 0.6547, 0.6579, 0.3266, 0.1129, 0.632, 0.2819, 0.3812, 0.2053, 0.375, 0.1119, 0.9609, 0.8885, 0.3793, 0.9901, 0.7077, 0.5275, 0.0626, 0.6026, 0.2853, 0.0171, 0.2841, 0.5639, 0.3862, 0.3156, 0.2918, 0.0615, 0.2435, 0.4499, 0.428, 0.4428, 0.3179],
    t::Vector{Float64} = [-2.54057, -2.53259, -2.52545, -2.58236, -2.51138, -2.58299, -2.51663, -2.57669, -2.57123, -2.55821, -2.53364],
)
    delta_t = m[2] - m[1]
    x = [sum(s[k] * sinc((ti - m[k])/delta_t) for k in eachindex(m)) for ti in t]
    return sum(x)
end
# działa